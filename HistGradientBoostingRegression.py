# -*- coding: utf-8 -*-
"""Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jDfj_4tF-In-siGxkXMY0F52VUgpPBOV
"""

import pandas as pd
from google.colab import drive
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestClassifier, BaggingRegressor, HistGradientBoostingRegressor
from sklearn.preprocessing import LabelEncoder, StandardScaler, RobustScaler, MinMaxScaler, OneHotEncoder, OrdinalEncoder, FunctionTransformer
from sklearn.compose import ColumnTransformer
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.pipeline import Pipeline
from sklearn.tree import DecisionTreeRegressor

"""# Understanding the data

"""

drive.mount('/content/drive')
df = pd.read_csv('/content/drive/MyDrive/AqarHunt_ds/AqurHunt.csv')
df

# configures the pandas library to display all columns of a DataFrame

pd.set_option("display.max_columns", None)

print(df.info())

print(df.describe())

#check for if we have missing values
total_missing_values = df.isnull().sum()
total_missing_values

# Drop rows where 'bathrooms' is explicitly 'None'
df = df[df['bathrooms'] != 'None']

# Convert 'bathrooms' and 'bedrooms' to numeric, handling errors
df['bathrooms'] = pd.to_numeric(df['bathrooms'], errors='coerce').astype('Int64')
df['bedrooms'] = pd.to_numeric(df['bedrooms'], errors='coerce').astype('Int64')

# Now drop NaN values that resulted from conversion
df = df.dropna(subset=['bedrooms', 'bathrooms'])

# Fill NaN values in 'down_payment_price' with 0
df['down_payment_price'] = df['down_payment_price'].fillna(0)

# Fill NaN values in 'district/compound' with 'unknown'
df['district/compound'] = df['district/compound'].fillna('unknown')

# Ensure 'furnished' column values are consistent for comparison
df['furnished'] = df['furnished'].astype(str).str.strip().str.capitalize()

# Update 'completion_status' based on 'furnished' values
df.loc[df['completion_status'].isna() & df['furnished'].isin(['Yes', 'Partly']), 'completion_status'] = 'Completed'
df.loc[df['completion_status'].isna() & df['furnished'].isin(['No']), 'completion_status'] = 'Unknown'

print(df.info())

#check for if we have missing values
total_missing_values = df.isnull().sum()
total_missing_values

# Convert 'listed_date' to datetime (handling UTC 'Z')
df['listed_date'] = pd.to_datetime(df['listed_date'], format="%Y-%m-%dT%H:%M:%SZ")

# Check for duplicates
duplicates = df.duplicated()
print(f"Number of duplicate rows: {duplicates.sum()}")

# Remove duplicates and keep the first occurrence
df = df.drop_duplicates()

# Reset index after removing duplicates (optional)
df.reset_index(drop=True, inplace=True)

#Ensure consistent capitalization in categorical columns
categorical_columns = df.select_dtypes(include='object').columns
for column in categorical_columns:
    df[column] = df[column].str.capitalize()

df.describe(include='object')

df.describe()

#The values for each categorical columns
unique_values = {}

for column in categorical_columns:
    unique_values[column] = df[column].unique()
    print(f"Unique values in '{column}':")
    print(unique_values[column])
    print()
#print(unique_values)

# To know the range of each category
# Group by price_category and find min and max prices
result = df.groupby('offering_type')['price'].agg(['min', 'max']).reset_index()
print(result)

#droping irrelvent columns
df.drop(columns=['id'], inplace=True)
df.drop(columns=['url+X13A1:V13'], inplace=True)
df.drop(columns=['location_full_name'], inplace=True)
df.drop(columns=['has_view_360'], inplace=True)
df.drop(columns=['amenity_names'], inplace=True)
df.drop(columns=['payment_method'], inplace=True)
df.drop(columns=['listed_date'], inplace=True)

df.select_dtypes(include = 'object').columns

df.dtypes

# Apply IQR method to remove outliers from 'price', 'size', 'bedrooms', and 'bathrooms'

for col in ['price', 'size', 'bedrooms', 'bathrooms']:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]

# Display the shape of the DataFrame after outlier removal
print("Shape of DataFrame after outlier removal:", df.shape)

# Create box plots again to visualize the data after outlier removal
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
sns.boxplot(y=df['price'])
plt.title('Box Plot of Price (After Outlier Removal)')
plt.ylabel('Price')

plt.subplot(2, 2, 2)
sns.boxplot(y=df['size'])
plt.title('Box Plot of Size (After Outlier Removal)')
plt.ylabel('Size')

plt.subplot(2, 2, 3)
sns.boxplot(y=df['bedrooms'])
plt.title('Box Plot of Bedrooms (After Outlier Removal)')
plt.ylabel('Bedroom Count')

plt.subplot(2, 2, 4)
sns.boxplot(y=df['bathrooms'])
plt.title('Box Plot of Bathrooms (After Outlier Removal)')
plt.ylabel('Bathroom Count')

plt.tight_layout()
plt.show()

# Ensure only numeric columns are included
numeric_df = df.select_dtypes(include=[np.number])

# Calculating the correlation matrix
correlation_matrix = numeric_df.corr()

# Visualizing the correlation matrix using a heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

"""# Ensemble

"""

dataset = df.copy()

categorical_cols = ['property_type', 'city', 'town', 'district/compound', 'completion_status', 'offering_type', 'furnished']
numerical_cols = ['lat', 'lon', 'bedrooms', 'bathrooms', 'size', 'down_payment_price'] # Removed 'price' from numerical_cols

# Define preprocessing steps for numerical and categorical features
numerical_transformer = MinMaxScaler()
categorical_transformer = OneHotEncoder(handle_unknown='ignore')

# Create a ColumnTransformer to apply different transformations to different columns
column_trans = ColumnTransformer(
    transformers=[
        ('num', numerical_transformer, numerical_cols),
        ('cat', categorical_transformer, categorical_cols)
    ],
    remainder='passthrough' # Keep other columns (like lat, lon, size, down_payment_price)
)

X = df.drop(columns='price')
y = df['price']

# Split into train and test sets
X_train, X_test, y_train, y_test = train_test_split(df.drop(columns='price'), df['price'], test_size=0.2, random_state=42)

# Define base estimator
base_estimator = DecisionTreeRegressor(max_depth=None, min_samples_leaf=2, random_state=42)


bag = BaggingRegressor(
        estimator      = base_estimator,
        n_estimators   = 500,      # large √N rule of thumb
        max_samples    = 0.8,      # bootstrap rows
        max_features   = 1.0,      # all columns per tree
        bootstrap      = True,
        oob_score      = True,     # free validation!
        n_jobs         = -1,
        random_state   = 42
)
model = Pipeline([('prep', column_trans), # Use column_trans for preprocessing
                  ('bag',  bag)])
model.fit(X_train, y_train)
print('OOB R²:', model[-1].oob_score_)          # quick sanity check

X_train_trans = column_trans.fit_transform(X_train)
X_test_trans = column_trans.transform(X_test)

# Convert to dense
X_train_dense = X_train_trans.toarray()
X_test_dense = X_test_trans.toarray()

# Define and train model directly
boost_model = HistGradientBoostingRegressor(
    learning_rate=0.1,
    max_iter=1000,
    max_depth=10,
    early_stopping=True,
    validation_fraction=0.1,
    n_iter_no_change=20,
    random_state=42
)

boost_model.fit(X_train_dense, y_train)

# Evaluate
y_train_pred = boost_model.predict(X_train_dense)
y_test_pred = boost_model.predict(X_test_dense)

print(f"R² on train: {r2_score(y_train, y_train_pred):.4f}")
print(f"R² on test : {r2_score(y_test, y_test_pred):.4f}")
print('MAE on test:', mean_absolute_error(y_test, y_test_pred))
print('MSE on test:', mean_squared_error(y_test, y_test_pred))
print('RMSE on test:', np.sqrt(mean_squared_error(y_test, y_test_pred)))

results = pd.DataFrame({
    'Actual Price (EGP)': y_test.values,
    'Predicted Price (EGP)': y_test_pred
})
display(
  results.head(20).style.format({
    'Actual Price (EGP)'   : '{:,.0f}',
    'Predicted Price (EGP)': '{:,.0f}'
  })
)

# Acutal vs Predicted Prices
plt.scatter(y_test, y_test_pred, alpha=0.3)
plt.xlabel("Actual Price (EGP)")
plt.ylabel("Predicted Price (EGP)")
plt.title("Actual vs Predicted Prices")
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.show()

"""# End to end functions"""

def predict_prices_for_multiple_properties(model, preprocessor):
    """
    Takes user input for multiple property features and stores them.

    Args:
        model: The trained regression model (not used in this function but included for consistency).
        preprocessor: The fitted ColumnTransformer used for preprocessing (not used in this function but included for consistency).

    Returns:
        A list of dictionaries, where each dictionary contains the details for a single property.
    """
    property_data_list = []
    print("Please enter the property details for multiple properties. Type 'quit' for property type to finish.")

    while True:
        # Get user input for each feature with error handling for numeric inputs
        property_type = input("Property Type (e.g., Apartment, Villa, Chalet) or 'quit' to finish: ").capitalize()
        if property_type == 'Quit':
            break

        if property_type == '':
            property_type = 'Unknown'
        city = input("City (e.g., Cairo, Giza): ").capitalize()
        if city == '':
            city = 'Unknown'
        town = input("Town (e.g., New Cairo, Sheikh Zayed): ").capitalize()
        if town == '':
            town = 'Unknown'
        district_compound = input("District/Compound (e.g., Fifth Settlement, Madinaty, unknown): ").capitalize()
        if district_compound == '':
            district_compound = 'Unknown'
        completion_status = input("Completion Status (e.g., Completed, Not Completed, Unknown): ").capitalize()
        if completion_status == '':
            completion_status = 'Unknown'
        offering_type = input("Offering Type (e.g., Sale, Rent): ").capitalize()
        if offering_type == '':
            offering_type = 'Unknown'
        furnished = input("Furnished (Yes, No, Partly): ").capitalize()
        if furnished == '':
            furnished = 'Unknown'

        while True:
            try:
                lat_input = input("Latitude: ")
                if lat_input == '':
                    lat = 0.0
                    break
                lat = float(lat_input)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for Latitude.")

        while True:
            try:
                lon_input = input("Longitude: ")
                if lon_input == '':
                    lon = 0.0
                    break
                lon = float(lon_input)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for Longitude.")

        while True:
            try:
                bedrooms_input = input("Number of Bedrooms: ")
                if bedrooms_input == '':
                    bedrooms = 0
                    break
                bedrooms = int(bedrooms_input)
                break
            except ValueError:
                print("Invalid input. Please enter an integer value for Number of Bedrooms.")

        while True:
            try:
                bathrooms_input = input("Number of Bathrooms: ")
                if bathrooms_input == '':
                    bathrooms = 0
                    break
                bathrooms = int(bathrooms_input)
                break
            except ValueError:
                print("Invalid input. Please enter an integer value for Number of Bathrooms.")

        while True:
            try:
                size_input = input("Size (in sqft or similar unit): ")
                if size_input == '':
                    size = 0.0
                    break
                size = float(size_input)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for Size.")

        while True:
            try:
                down_payment_price_input = input("Down Payment Price (enter 0 if not applicable): ")
                if down_payment_price_input == '':
                    down_payment_price = 0.0
                    break
                down_payment_price = float(down_payment_price_input)
                break
            except ValueError:
                print("Invalid input. Please enter a numeric value for Down Payment Price.")

        # Create a dictionary from user input and append to the list
        property_data = {
            'property_type': property_type,
            'city': city,
            'town': town,
            'district/compound': district_compound,
            'completion_status': completion_status,
            'offering_type': offering_type,
            'furnished': furnished,
            'lat': lat,
            'lon': lon,
            'bedrooms': bedrooms,
            'bathrooms': bathrooms,
            'size': size,
            'down_payment_price': down_payment_price
        }
        property_data_list.append(property_data)
        print("-" * 30) # Separator for next input

    return property_data_list

def preprocess_and_predict_multiple(property_data_list, model, preprocessor):
    """
    Preprocesses a list of property data dictionaries, predicts prices, and returns the results.

    Args:
        property_data_list: A list of dictionaries, where each dictionary contains the details for a single property.
        model: The trained regression model.
        preprocessor: The fitted ColumnTransformer used for preprocessing.

    Returns:
        A list of dictionaries, where each dictionary contains the original property details and the predicted price.
    """
    results_list = []
    for property_data in property_data_list:
        # Convert the single property data dictionary to a DataFrame
        input_df = pd.DataFrame([property_data])

        # Preprocess the input data
        input_data_processed = preprocessor.transform(input_df)

        # Convert to dense array if the preprocessor output is sparse
        if hasattr(input_data_processed, 'toarray'):
            input_data_processed = input_data_processed.toarray()

        # Make the prediction
        predicted_price = model.predict(input_data_processed)

        # Add the predicted price to the property data dictionary
        property_data['predicted_price'] = predicted_price[0]

        # Append the updated dictionary to the results list
        results_list.append(property_data)

    return results_list


# Collect property data from the user
collected_property_data = predict_prices_for_multiple_properties(boost_model, column_trans)

# Preprocess the collected data and get predictions
predicted_results = preprocess_and_predict_multiple(collected_property_data, boost_model, column_trans)

# Display the results
print("\n--- Prediction Results ---")
for result in predicted_results:
    print(f"Property Details: {result}")
    print(f"Predicted Price: {result['predicted_price']:,.2f} EGP")
    print("-" * 30)







